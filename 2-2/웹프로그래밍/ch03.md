# 3장 어플리케이션 아키텍쳐
-> 애플리케이션의 구조화와 설계 및 개념을 이해하자!

# 3-1 MVC와 ADR
* 처음 MVC는 프론트단 개발 패턴
  BUT) 백엔드단 개발 패턴으로 적용한 것: MVC2 패턴 ... P.102 / 그림 3.1
  MVC2패턴은 MVC패턴이라고 통칭

@프로젝트 새로 만들어서 진행 - 1장 참고 -

* 컨트롤러(UserController) 생성: 터미널에 실행
./vendor/bin/sail artisan make:controller UserController

* 컨트롤러
  - 액션메서드: 라우터에 등록되어 있는 URL로 요청되면 실행되는 메서드
  - 리소스 컨트롤러: CRUD 기능하는 메서드를 가지고 있는 컨트롤러
  - 라우터에서 지정된 컨트롤러 클래스와 메서드의 쌍으로 호출되어 Request에 대해 Response처리

* 모델
  - 비즈니스 로직처리가 중요
  - 일반적인 인식: DB의 테이블과 동일시 경향: 오해 소지 있음***
  - 개발자가 제일 고심 해야하는 부분(요구사항에 대한 처리를 수행: 비즈니스 로직)
  - 일반적인 웹 앱 모델 (cf: P.123):
    - 비즈니스 로직 구현 계층: ~Service, ~Repository
    - 데이터베이스 조작계층: 일반적으로 우리가 인식하고 있는 모델(User)
      - Eloquent ORM/QueryBuilder 라이브러리 사용

* 작은 규모의 서비스
  - 실수할 수 있는 형태: 사용자가 늘고 서비스가 늘어나는데, 유지보수가 늘어남(못할 수도..)..
    => 실수가 있어도 가장 줄이기 위해서 계층화가 필요함!
  - cf.Fat모델 상태로 개발: 비즈니스 처리와 DB처리가 한 소스코드에 작성됨
    => 서비스의 커짐에 따라 굉장하게 복잡해 질 수 있다..
    ---> 강한 결합--->해결: DI
* Fat모델이 되지 않도록 계층을 나눠서 개발하기(cf: P.105~7)
  1) 트랜젝션 스크립트 패턴(cf: P.106)
    - 가능한 모델과 관련된 소스코드없이 서비스 위주로 코드를 구현.
    * 장점: 간단하다. 바로 구현이 가능
    * 단점: 규모가 확장됨에 따라 클래스의 복잡도가 높아지고, 유지보수가 곤란, 일관성 결여(하락)
      -> 전체 서비스 내용 파악이 어려움
    => 해결방안: 계층화 / Layered Architecture(레이어드 아키텍처) "#3장 2-3"
      - ~Service, ~Repository 등으로 구현

  2) 도메인 모델 패턴(DDD: Domain Driven Design): 경험하기 어려움
    - 요구사항에 대한 세밀한 분석이 필요(개발에 여러회사가 같이하는데 회사마다 요구사항이 많이 다름..)
    - 1번의 트랜젝션 스크립트 패턴보다 난의도가 높다.

cf) foreach(배열변수 as 요소/원소 변수) {
      (요소/원소 변수)로 처리;
    }

* View(뷰)
  - Blade 템플릿
    - 관련 인스턴스: Illuminate\Http\Response 클래스의 인스턴스

# 3-1-2 ADR
Action
Domain
Responder

-> 표준적으로는 MVC에 따르나 / App\Http\안에 Action 폴더를 생성하여 코드 작성!
-> 아티산에는 아직 없음 -> 표준적이지는 않다..(현재 기준으로.)
* MVC vs ADR
  - Model vs Domain
  - view vs Responder
  - Controller vs Action
=> 계층화로 좀더 복잡하고 어려운 서비스를 개발 할 수 있으나 대략적으로 비슷하다 -> 구현에 있어서 Domain에서 조금 달라짐.

* Action(액션): 연결도 확실해지고 간단해짐!!
  - Controller에 대응: controller는 action메서드
  - 하나의 액션 메서드에 대해 하나의 Action클래스로 구현 => 여러 클래스로 구현할 경우 -> 명확하지 않아짐..
      => 에러: 에러난 클래스 하나만을 보면됨 -> 유지보수하기 쉬워짐.
    - UserIndexAction 클래스
    - UserStoreAction
    - UserDetailAciton
  - Route::get('users',App\Http\Action\UserIndexAction::class);
    UserIndexAction의 __invoke()가 호출됨.

* Domain
  - 모델과 거의 유사
  - Fat모델형태 구현 회피: Layered Architecture(레이어드 아키텍처) 구현
    - ~Service--- ~Repository--- ~Model 형태로 계층적으로 구현
  - 도메인 모델 패턴(DDD)에서 모델을 도메인으로 표현

* 리스폰더(Responder)
  - 뷰(view)에 대응
  - HTTP 응답처리
    view(), response(), Response 파사드, response 클래스의 인스턴스로 처리
  - ~Responder 클래스 내에 response()메서드 구현

* ADR 단점(cf: P.115)
  - 클래스가 많아짐 => 긍적적인 측면: 역할이 명확해져, 유지보수가 간단해짐!!

* 프레임워크와 이키텍쳐 설계(cf: P.117)
  - 다변화하는 다양한 요구(비즈니스 요구)에 대하여 대응하도록 프레임워크 뼈대(2장의 내용)를 기반으로 적절한 아키텍쳐 설계가 되어야 함
  - 적절한 아키텍쳐
    - MVC / ADR의 형태 상관없이
    - 1_애플리케이션(앱)의 품질, 2_구현용이성, 3_유지보수성, 4_확장성으로 고려해야 구현해야 함 (사람들마다 다를 수 있음)
      ## 객체지향!!!언어의 중요성! - 상속 / interface
      1_: 4장의 에러없이 데이터를 받음으로써 품질향상
  - 다변화하는 다양한 요구(비즈니스 요구)
    1) 기능 요구사항
      - 비즈니스 로직으로 구현
    2) 비기능 요구사항(이에 따라 연봉이 달라짐!!!!!!)
      - 보안, 성능(속도)
    => 추상화, 구조화: MVC & ADR의 기반으로 비즈니스 로직과 DB처리 부분을 나누는 것이 권장됨.
    !! 레이어드 아키텍쳐로 구현!!

* Layered Architecture(레이어드 아키텍쳐): (cf: 내용 - P.119 / 그림 - P.123)
  1) 컨트롤러-모델 구현(리스트 3.12)에서 서비스 클래스로 분리 (cf: 리스트 3.13~4 / P.119~20)
    - 교과서: 모델과 컨트롤러 분리(서비스 클래스를 이용해서) / 관례: ~Service
  2) 서비스클래스에서 모델 분리(레포지토리를 이용해서) (cf: 리스트 3.15~7 / P.123~4)
    - Repository: 저장소
    - 인터페이스 구현: 확장성 / interface특성상 반드시 구현해야하는 메소드가 있음!!

  => DDD(도메인 주도 설계 방법)
    - 기업마다 달라, 가서 배워야함.. 초보자에서는 다룰 수 없음..


## 정리: 시스템을 레이아웃으로 나눠, 코드 유지보수가 쉽고 간단해짐!